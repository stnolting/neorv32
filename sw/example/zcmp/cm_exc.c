// Zcmp exception edge-case tests
//
// Verifies that load/store micro-ops generated by cm.push / cm.pop trigger
// the correct exception (store-access-fault / load-access-fault), that mepc
// reports the address of the *original* Zcmp instruction, and that the Zcmp
// FSM recovers cleanly so subsequent Zcmp instructions still work.
//
// Because the standard RTE first-level handler builds its stack frame on the
// current sp, we cannot let the RTE run when sp points to invalid memory.
// Instead, a minimal naked trap handler is installed temporarily. It uses
// mscratch to swap in a known-good stack, records mepc / mcause, advances
// mepc past the compressed Zcmp instruction (+2), and returns via mret.

#include <neorv32.h>
#include "cm_exc.h"

// ---------------------------------------------------------------------------
// Trap recording
// ---------------------------------------------------------------------------
static volatile uint32_t exc_mepc;
static volatile uint32_t exc_mcause;
static volatile uint32_t exc_count;

// Separate stack used exclusively by the minimal trap handler.
static uint32_t exc_stack[64] __attribute__((aligned(16)));

// ---------------------------------------------------------------------------
// Minimal trap handler (naked - no prologue / epilogue)
//
// Expects mscratch to hold a valid stack pointer (top of exc_stack).
// Saves only a0/a1, records mepc and mcause, advances mepc by 2 (compressed
// instruction), restores a0/a1, swaps sp back, and returns.
// ---------------------------------------------------------------------------
static void __attribute__((naked, aligned(4))) zcmp_exc_handler(void)
{
  asm volatile(
      // swap sp with known-good stack in mscratch
      "csrrw sp, mscratch, sp    \n"
      // save working registers
      "addi  sp, sp, -8          \n"
      "sw    a0, 0(sp)           \n"
      "sw    a1, 4(sp)           \n"
      // record mepc
      "csrr  a0, mepc            \n"
      "la    a1, exc_mepc        \n"
      "sw    a0, 0(a1)           \n"
      // record mcause
      "csrr  a0, mcause          \n"
      "la    a1, exc_mcause      \n"
      "sw    a0, 0(a1)           \n"
      // increment counter
      "la    a1, exc_count       \n"
      "lw    a0, 0(a1)           \n"
      "addi  a0, a0, 1           \n"
      "sw    a0, 0(a1)           \n"
      // advance mepc past compressed Zcmp instruction (+2)
      "csrr  a0, mepc            \n"
      "addi  a0, a0, 2           \n"
      "csrw  mepc, a0            \n"
      // restore and return
      "lw    a0, 0(sp)           \n"
      "lw    a1, 4(sp)           \n"
      "addi  sp, sp, 8           \n"
      "csrrw sp, mscratch, sp    \n"
      "mret                      \n");
}

// ---------------------------------------------------------------------------
// Install / restore trap handler helpers
// ---------------------------------------------------------------------------
static uint32_t saved_mtvec;

static void install_exc_handler(void)
{
  // pre-load mscratch with top of the trap-handler stack
  neorv32_cpu_csr_write(CSR_MSCRATCH, (uint32_t)&exc_stack[63]);
  // save current mtvec (the RTE handler) and install ours
  saved_mtvec = neorv32_cpu_csr_read(CSR_MTVEC);
  neorv32_cpu_csr_write(CSR_MTVEC, (uint32_t)(&zcmp_exc_handler));
}

static void restore_rte_handler(void)
{
  neorv32_cpu_csr_write(CSR_MTVEC, saved_mtvec);
}

// ---------------------------------------------------------------------------
// Test: cm.push store-access-fault
//
// Point sp to unmapped address space (0xA0000080). The first store micro-op
// will trigger a bus error -> store access fault.  Verify mepc points to the
// cm.push instruction and mcause == TRAP_CODE_S_ACCESS.
// ---------------------------------------------------------------------------
static int test_push_store_fault(void)
{
  uint32_t bad_sp = 0xA0000080u;
  uint32_t zcmp_pc = 0;

  exc_count = 0;
  exc_mepc = 0;
  exc_mcause = 0;

  asm volatile(
      // save real sp
      "mv   t1, sp               \n"
      // install bad sp
      "mv   sp, %[bad]           \n"
      // load a value into x1 (ra) so the push has something to store
      "li   x1, 0xa5000001       \n"
      // capture the address of the upcoming Zcmp instruction
      "la   %[pc], 1f            \n"
      // cm.push {ra}, -16  (encoding 0xb842)
      "1: .hword 0xb842          \n"
      // after trap handler skips the push we land here; restore sp
      "mv   sp, t1               \n"
      : [pc] "=r"(zcmp_pc)
      : [bad] "r"(bad_sp)
      : "t1", "x1", "memory");

  int ok = 1;

  if (exc_mcause != TRAP_CODE_S_ACCESS)
  {
    neorv32_uart0_printf("  mcause: expected 0x%x, got 0x%x\n", (uint32_t)TRAP_CODE_S_ACCESS, exc_mcause);
    ok = 0;
  }
  if (exc_mepc != zcmp_pc)
  {
    neorv32_uart0_printf("  mepc: expected 0x%x, got 0x%x\n", zcmp_pc, exc_mepc);
    ok = 0;
  }
  if (exc_count != 1)
  {
    neorv32_uart0_printf("  trap count: expected 1, got %u\n", exc_count);
    ok = 0;
  }

  return ok;
}

// ---------------------------------------------------------------------------
// Test: cm.pop load-access-fault
//
// Point sp to unmapped address space. The first load micro-op will trigger
// a bus error -> load access fault.  Verify mepc and mcause.
// ---------------------------------------------------------------------------
static int test_pop_load_fault(void)
{
  uint32_t bad_sp = 0xA0000080u;
  uint32_t zcmp_pc = 0;

  exc_count = 0;
  exc_mepc = 0;
  exc_mcause = 0;

  asm volatile(
      // save real sp
      "mv   t1, sp               \n"
      // install bad sp
      "mv   sp, %[bad]           \n"
      // capture the address of the Zcmp instruction
      "la   %[pc], 1f            \n"
      // cm.pop {ra}, 16  (encoding 0xba42)
      "1: .hword 0xba42          \n"
      // after trap handler skips the pop we land here; restore sp
      "mv   sp, t1               \n"
      : [pc] "=r"(zcmp_pc)
      : [bad] "r"(bad_sp)
      : "t1", "x1", "memory");

  int ok = 1;

  if (exc_mcause != TRAP_CODE_L_ACCESS)
  {
    neorv32_uart0_printf("  mcause: expected 0x%x, got 0x%x\n", (uint32_t)TRAP_CODE_L_ACCESS, exc_mcause);
    ok = 0;
  }
  if (exc_mepc != zcmp_pc)
  {
    neorv32_uart0_printf("  mepc: expected 0x%x, got 0x%x\n", zcmp_pc, exc_mepc);
    ok = 0;
  }
  if (exc_count != 1)
  {
    neorv32_uart0_printf("  trap count: expected 1, got %u\n", exc_count);
    ok = 0;
  }

  return ok;
}

// ---------------------------------------------------------------------------
// Test: Zcmp FSM recovery after fault
//
// Execute a normal cm.push {ra}, -16 on valid memory *after* the fault tests.
// If the Zcmp module's FSM did not recover properly from the abort, this will
// hang or produce wrong results.
// ---------------------------------------------------------------------------
#define RECOVERY_FRAME_WORDS 32
static uint32_t recovery_frame[RECOVERY_FRAME_WORDS] __attribute__((aligned(16)));

static int test_recovery(void)
{
  volatile uint32_t *test_sp = &recovery_frame[RECOVERY_FRAME_WORDS];

  // fill frame with known pattern
  for (int i = 0; i < RECOVERY_FRAME_WORDS; i++)
    recovery_frame[i] = 0xdead0000 + i;

  asm volatile(
      // save real sp, install test sp
      "mv   t0, sp               \n"
      "mv   sp, %[tsp]           \n"
      // load unique register values
      "li   x1,  0xa5000001      \n"
      // cm.push {ra}, -16
      ".hword 0xb842             \n"
      // capture sp after push
      "mv   %[tsp], sp           \n"
      // restore real sp
      "mv   sp, t0               \n"
      : [tsp] "+r"(test_sp)
      :
      : "t0", "x1", "memory");

  // expected: ra (0xa5000001) stored at frame[31], sp decremented by 16
  int ok = 1;

  uint32_t sp_diff = (uint32_t)test_sp - (uint32_t)&recovery_frame[RECOVERY_FRAME_WORDS];
  if (sp_diff != (uint32_t)-16)
  {
    neorv32_uart0_printf("  sp adjustment: expected -16, got %d\n", (int32_t)sp_diff);
    ok = 0;
  }
  if (recovery_frame[RECOVERY_FRAME_WORDS - 1] != 0xa5000001)
  {
    neorv32_uart0_printf("  ra not stored correctly: expected 0xa5000001, got 0x%x\n", recovery_frame[RECOVERY_FRAME_WORDS - 1]);
    ok = 0;
  }

  return ok;
}

// ---------------------------------------------------------------------------
// entry point
// ---------------------------------------------------------------------------
int cm_exc(void)
{
  int result = 0;

  neorv32_uart0_printf("\n--- Zcmp exception tests ---\n");

  install_exc_handler();

  neorv32_uart0_printf("cm.push store-access-fault");
  if (test_push_store_fault())
  {
    neorv32_uart0_printf(" - OK\n");
  }
  else
  {
    neorv32_uart0_printf(" - FAIL\n");
    result = 1;
  }

  neorv32_uart0_printf("cm.pop load-access-fault");
  if (test_pop_load_fault())
  {
    neorv32_uart0_printf(" - OK\n");
  }
  else
  {
    neorv32_uart0_printf(" - FAIL\n");
    result = 1;
  }

  restore_rte_handler();

  // recovery test uses the normal RTE (sp is valid during this test)
  neorv32_uart0_printf("cm.push recovery after fault");
  if (test_recovery())
  {
    neorv32_uart0_printf(" - OK\n");
  }
  else
  {
    neorv32_uart0_printf(" - FAIL\n");
    result = 1;
  }

  if (result == 0)
  {
    neorv32_uart0_printf("All exception tests PASSED.\n");
  }
  else
  {
    neorv32_uart0_printf("Some exception tests FAILED.\n");
  }

  return result;
}
