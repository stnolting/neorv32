<<<
:sectnums:
==== Processor-External Bus Interface (XBUS)

[cols="<3,<3,<4"]
[grid="none"]
|=======================
| Hardware source files:  | neorv32_xbus.vhd        | External bus gateway
|                         | neorv32_cache.vhd       | Generic cache module
| Software driver files:  | none                    |
| Top entity ports:       | `xbus_adr_o`            | address output (32-bit)
|                         | `xbus_dat_i`            | data input (32-bit)
|                         | `xbus_dat_o`            | data output (32-bit)
|                         | `xbus_tag_o`            | access tag (3-bit)
|                         | `xbus_we_o`             | write enable (1-bit)
|                         | `xbus_sel_o`            | byte enable (4-bit)
|                         | `xbus_stb_o`            | bus strobe (1-bit)
|                         | `xbus_cyc_o`            | valid cycle (1-bit)
|                         | `xbus_ack_i`            | acknowledge (1-bit)
|                         | `xbus_err_i`            | bus error (1-bit)
| Configuration generics: | `XBUS_EN`               | enable external bus interface when `true`
|                         | `XBUS_TIMEOUT`          | number of clock cycles after which an unacknowledged external bus access will auto-terminate (0 = disabled)
|                         | `XBUS_REGSTAGE_EN`      | implement XBUS register stages
|                         | `XBUS_CACHE_EN`         | implement the external bus cache when `true`
|                         | `XBUS_CACHE_NUM_BLOCKS` | number of cache blocks (pages or lines); has to be a power of two
|                         | `XBUS_CACHE_BLOCK_SIZE` | size of a cache block in bytes; has to be a power of two
| CPU interrupts:         | none |
|=======================


**Overview**

The external bus interface provides a **Wishbone b4**-compatible on-chip bus interface that gets
implemented if the `XBUS_EN` generic is `true`. This bus interface can be used to attach processor-external
modules like memories, custom hardware accelerators or additional peripheral devices.
An optional cache module ("XCACHE") can be enabled to improve memory access latency.

.Address Mapping
[IMPORTANT]
The external interface is **not** mapped to a specific address space. Instead, all CPU memory accesses that
do not target a specific (and actually implemented) processor-internal address region (hence, accessing the "void";
see section <<_address_space>>) are **redirected** to the external bus interface.

.AXI4 Interface Bridge
[TIP]
A simple bridge that converts the processor's XBUS into an AXI4-compatible host interface can
be found in `rtl/system_inegration` (`xbus2axi4_bridge.vhd`). Note that the AXI specifications
do not allow any bus timeouts. Hence, `XBUS_TIMEOUT` should be set to zero (disabling the bus timeout)
when using the XBUS-AXI bridge.


**XBUS Bus Protocol**

The external bus interface complies to the **pipelined Wishbone b4** protocol. Even though this protocol
was explicitly designed to support pipelined transfers, only a single transfer will be "in fly" at once.
Hence, just two types of bus transactions are generated by the XBUS controller (see images below).

.XBUS Write Transaction
[wavedrom, format="svg", align="center"]
----
{signal: [
  {name: 'clk',         wave: 'p....|...'},
  {name: 'xbus_adr_o',  wave: 'x3...|.x.', data: ['address']},
  {name: 'xbus_dat_i',  wave: 'x....|.x.'},
  {name: 'xbus_dat_o',  wave: 'x3...|.x.', data: ['wdata']},
  {name: 'xbus_we_o',   wave: 'x1...|.x.'},
  {name: 'xbus_sel_o',  wave: 'x3...|.x.', data: ['byte_enable']},
  {name: 'xbus_stb_o',  wave: '010..|...'},
  {name: 'xbus_cyc_o',  wave: '01...|.0.'},
  {name: 'xbus_ack_i',  wave: 'x0...|1x.'},
  {name: 'xbus_err_i',  wave: 'x0...|.x.'},
]}
----

.XBUS Read Transaction
[wavedrom, format="svg", align="center"]
----
{signal: [
  {name: 'clk',         wave: 'p....|...'},
  {name: 'xbus_adr_o',  wave: 'x3...|.x.', data: ['address']},
  {name: 'xbus_dat_i',  wave: 'x....|3x.', data: ['rdata']},
  {name: 'xbus_dat_o',  wave: 'x....|.x.'},
  {name: 'xbus_we_o',   wave: 'x0...|.x.'},
  {name: 'xbus_sel_o',  wave: 'x....|.x.'},
  {name: 'xbus_stb_o',  wave: '010..|...'},
  {name: 'xbus_cyc_o',  wave: '01...|.0.'},
  {name: 'xbus_ack_i',  wave: 'x0...|1x.'},
  {name: 'xbus_err_i',  wave: 'x0...|.x.'},
]}
----

.Wishbone "Classic" Protocol
[IMPORTANT]
Native support for the "classic" Wishbone protocol has been deprecated.
However, classic mode can still be _emulated_ by connecting the processor's `xbus_cyc_o` directly to the
device's / bus system's `cyc` and `stb` signals (omitting the processor's `xbus_stb_o` signal).

.Atomic Memory Accesses
[IMPORTANT]
<<_atomic_memory_access>> operations (read-modify-write) keep the `cyc` signal active to perform a
back-to-back bus access consisting of two `stb` strobes (one for the load/read operation and another
one for the store/write operation). Reservation-set operations (<<_zalrsc_isa_extension>>) are not
propagated via the XBUS interface and appear as normal load/store operations.

.Wishbone Specs.
[TIP]
A detailed description of the implemented Wishbone bus protocol and the according interface signals
can be found in the data sheet "Wishbone B4 - WISHBONE System-on-Chip (SoC) Interconnection
Architecture for Portable IP Cores". A copy of this document can be found in the `docs` folder of this
project.

An accessed XBUS/Wishbone device does not have to respond immediately to a bus request by sending an `ACK`.
Instead, there is a **time window** where the device has to acknowledge the transfer. This time window
is configured by the `XBUS_TIMEOUT` generic and it defines the maximum time (in clock cycles) a bus access can
be pending before it is automatically terminated raising an bus fault exception. If `XBUS_TIMEOUT` is set to zero,
the timeout is disabled and a bus access can take an arbitrary number of cycles to complete. Note that this is not
recommended as a missing ACK will permanently stall the entire processor!

Furthermore, an accesses XBUS/Wishbone device can signal an error condition at any time by setting the `ERR` signal
high for one cycle. This will also terminate the current bus transaction before raising a CPU bus fault exception.

.Register Stage
[TIP]
An optional register stage can be added to the XBUS gateway to break up the critical path easing timing closure.
When `XBUS_REGSTAGE_EN` is _true_ all outgoing and incoming XBUS signals are registered increasing access latency
by two cycles. Furthermore, all outgoing signals (like the address) will be kept stable if there is no bus access
being initiated.


**Access Tag**

The XBUS tag signal `xbus_tag_o(0)` provides additional information about the current access cycle.
It compatible to the AXI4 `ARPROT` and `AWPROT` signals.

* `xbus_tag_o(0)` **P**: access is performed from **privileged** mode (machine-mode) when set
* `xbus_tag_o(1)` **NS**: this bit is hardwired to `0` indicating a **secure** access
* `xbus_tag_o(2)` **I**: access is an **instruction** fetch when set; access is a data access when cleared


**External Bus Cache (XBUS-CACHE)**

The XBUS interface provides an optional internal cache that can be used to buffer processor-external accesses.
The x-cache is enabled via the `XBUS_CACHE_EN` generic. The total size of the cache is split into the number of
cache lines or cache blocks (`XBUS_CACHE_NUM_BLOCKS` generic) and the line or block size in bytes
(`XBUS_CACHE_BLOCK_SIZE` generic). The cache uses a direct-mapped architecture that implements "write-allocate"
and "write-back" strategies.

.Uncached Accesses
[NOTE]
The data cache provides direct accesses (= uncached) to memory in order to access memory-mapped IO.
All accesses that target the address range from `0xF0000000` to `0xFFFFFFFF`
will not be cached at all (see section <<_address_space>>). Furthermore, the atomic memory operations
of the <<_zaamo_isa_extension>> will always **bypass** the cache.

.Manual Cache Flush/Clear/Reload and Memory Coherence
[NOTE]
By executing a `fence` **or** `fence.i` instruction the XBUS cache is flushed (local modifications are send back to
main memory), cleared (all cache entries are invalidated) and a reloaded (fetching new data from main memory).
See section <<_memory_coherence>> for more information.

.Retrieve Cache Configuration from Software
[TIP]
Software can retrieve the cache configuration/layout from the <<_sysinfo_cache_configuration>> register.

.Bus Access Fault Handling
[NOTE]
If the cache encounters a bus error when uploading a modified block to the next memory level or when
downloading a new block from the next memory level, the entire block is invalidated and a bus access
error exception is raised.
